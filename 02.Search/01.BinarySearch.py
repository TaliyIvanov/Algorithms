"""
Алгоритм бинарной сортировки достаточно прост в освоении.
Мы делим массив на определенное число в зависимости от того,
больше/меньше наш элемент.

Принципиально мы:
- Получаем отсортированный массив и значение элемента, который ищем;
- Заводим 2 указателя (левый, правый);
- Пока левый указатель меньше или правого:
    - Создаем центральный указатель, чтобы он обновлялся внутри цикла
    - Если элемент в середине равен нашему таргету, возвращаем его;
    - Если элемент в середине списка меньше таргета:
        Сдвигаем левый указатель на позицию центрального + 1;
    - Если элемент в середине списка больше таргета:
        Сдвигаем правый указатель на позицию центрального - 1;

- Если цикл завершился - возвращаем сообщение об отсутствии элемента в массиве.

Таким образом, с каждой итерацией мы сокращаем "ПОЛЕ" поиска по массиву в два раза,
что положительно сказывается на эффективности выполнения алгоритма.

Важно помнить:
- Принцип "Разделяй и властвуй";
- Алгоритм должен получать отсортированный массив;
- Асимптотика O(logn), т.к. каждый раз мы делим на определнное число. не обязательно 2

Реализация на Python:
"""

def MyBinarySearch(arr, target):
    left = 0
    right = len(arr) - 1

    while left < right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return print(f'Индекс элемента: {mid}')
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return print('Элемента с таким значением нет в массиве')

arr = [-20, -16, -15, -15, -14, -13, -7, -5, -4, 0, 0, 1, 5, 7, 11, 12, 13, 15, 16, 20]

MyBinarySearch(arr, 1)
"""
Индекс элемента: 11
"""
MyBinarySearch(arr, 666)
"""
Элемента с таким значением нет в массиве
"""