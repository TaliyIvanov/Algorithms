"""
Сортировка подсчётом (counting sort) — это алгоритм сортировки, работающий за линейное время,
который подходит для сортировки целых чисел из известного диапазона. Он не основан на
сравнении элементов, в отличие от многих других алгоритмов сортировки (например, пузырьковой,
быстрой, сортировки слиянием).  Вместо этого он подсчитывает количество вхождений
каждого элемента и затем использует эту информацию для размещения элементов в правильном порядке.

Алгоритм:

1. **Нахождение диапазона:** Определяется минимальное и максимальное значения во входном массиве.
Это определяет диапазон значений, которые нужно подсчитывать.
2. **Создание массива подсчёта:** Создаётся вспомогательный массив (список в Python),
индексированный значениями из диапазона. Каждый элемент этого массива изначально равен нулю.
3. **Подсчёт:**  Проходим по входному массиву. Для каждого элемента увеличиваем значение
в массиве подсчёта по индексу, равному значению этого элемента.  Таким образом, `counts[i]`
будет содержать количество элементов, равных `i` во входном массиве.
4. **Накопление:**  Преобразуем массив подсчёта в массив накопленных сумм.
Каждый элемент `counts[i]`  становится равен сумме  `counts[0] + counts[1] + ... + counts[i]`.
Это позволяет определить позицию каждого элемента в отсортированном массиве.
5. **Размещение элементов:** Создаётся новый массив того же размера, что и входной.
Проходим по входному массиву в обратном порядке. Для каждого элемента `x` смотрим значение
в `counts[x]`.  `counts[x] - 1`  указывает индекс в выходном массиве, куда нужно поместить  `x`.
После этого уменьшаем  `counts[x]` на 1. Обратный порядок обхода важен для сохранения
стабильности сортировки (элементы с одинаковым значением сохраняют свой относительный порядок).

Асимптотика:

* Временная сложность: O(n + k), где n - количество элементов во входном массиве,
k - диапазон значений (max - min + 1).  Если k = O(n), то сложность становится O(n),
что является линейной.

* Пространственная сложность: O(k), так как требуется дополнительная память для
массива подсчёта.

Ограничения:

* Требует знания диапазона значений заранее.
* Работает только для целых чисел.
* Эффективна, когда диапазон значений (k) ненамного больше количества элементов (n).
Если k значительно больше n, то использование памяти может стать проблемой.
Не подходит для сортировки чисел с плавающей точкой или строк.

"""

def MyCountingSort(arr):
    # получаем диапазон значений
    num_min = min(arr)
    num_max = max(arr)
    # вычисляем необходимое кол-во ячеек для списка
    range_size = num_max - num_min + 1
    # Создаем список нулей, для подсчета количеств элементов
    counts = [0] * range_size
    print(f'Список счетчиков для подсчета кол-ва эл-ов исходного массива: {counts}')

    # в данном цикле разница значения элемента исходного массива и единицы
    # является индексом в массиве-счетчике значений элементов
    for elem in arr:
        counts[elem - num_min] += 1

    print(f'Подсчитанное кол-во элементов счетчиками: {counts}')

    # вот тут заключена основная "магия" алгоритма в вычислении позиции эл-та
    # прибавляя счетчик предыдущего элемента, мы получаем его позицию в
    # отсортированном массиве + 1
    for i in range(1, range_size):
        counts[i] += counts[i - 1]
    print(f'Финальная позиция элемента в отсортированном массиве: {counts}')

    # создаем финальный массив, размером с исходный
    output = [0] * len(arr)
    # проходим по исходному массиву в обратном порядке
    # сопоставляя значение элемента с индексом в массиве-счетчике
    for elem in reversed(arr):
        final_pos = counts[elem - num_min] - 1
        output[final_pos] = elem
        counts[elem - num_min] -= 1

    return output


# Примеры:
print("Пример 1:")
data = [4, 2, -2, 8, 3, -3, 3, -1, 1]
sorted_data = MyCountingSort(data)
print(f"Отсортированный массив: {sorted_data}") # Output: [1, 2, 2, 3, 3, 4, 8]

"""
Пример 1:
Список счетчиков для подсчета кол-ва эл-ов исходного массива: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Подсчитанное кол-во элементов счетчиками: [1, 1, 1, 0, 1, 1, 2, 1, 0, 0, 0, 1]
Финальная позиция элемента в отсортированном массиве: [1, 2, 3, 3, 4, 5, 7, 8, 8, 8, 8, 9]
Отсортированный массив: [-3, -2, -1, 1, 2, 3, 3, 4, 8]
"""