"""
Алгоритм разделения Ломуто (Lomuto partition scheme) — это альтернативный
способ разделения массива, который используется, например, в быстрой сортировке (Quick Sort).
Его особенностью является выбор опорного элемента (pivot) и перераспределение элементов
массива так, чтобы слева оказались все элементы меньше или равные опорному,
а справа — больше опорного.

### Основные особенности алгоритма Ломуто:
1. **Опорный элемент:** Обычно выбирается последний элемент массива,
но может быть выбран и любой другой.
2. **Указатели:** Алгоритм использует один указатель (`i`),
который отслеживает положение, где должны находиться элементы, меньшие или равные опорному.
3. **Простота реализации:** Алгоритм проще в реализации, чем схема Хоара,
но менее эффективен в некоторых ситуациях.

### Шаги алгоритма Ломуто:
1. **Выбор опорного элемента (pivot):** Обычно выбирается последний элемент массива.
2. **Инициализация указателя `i`:** Он указывает на место, где следующий элемент,
меньший или равный `pivot`, должен быть размещён.
3. **Перебор массива:** Для каждого элемента массива (кроме опорного):
    - Если элемент меньше или равен `pivot`, он меняется местами с элементом
    на позиции `i`, и `i` увеличивается.
4. **Помещение опорного элемента на своё место:** После завершения перебора
массива опорный элемент меняется местами с элементом на позиции `i`.
5. **Результат:** Все элементы слева от опорного меньше или равны ему,
а все элементы справа больше.

### Преимущества алгоритма Ломуто:

- Простая реализация.
- Хорошо работает на небольших массивах или когда массив почти отсортирован.
### Недостатки:
- Меньшая производительность в среднем случае по сравнению с Хоаром.
- При неблагоприятном выборе опорного элемента (например, минимальный или максимальный)
может привести к квадратичной сложности O(n2)O(n^2).
"""

def MyPartitionLomuto(arr):
    pivot = arr[-1]    # Выбираем последний элемент в качестве опорного
    i = -1    # Указатель для меньших элементов
    for j in range(len(arr) - 1):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]


    # меняем местами опорный элемент и элемент на позиции i + 1
    arr[i + 1], arr[(len(arr) - 1)] = arr[(len(arr) - 1)], arr[i + 1]
    # индекс опорного элемента
    pivot_index = i + 1
    return pivot_index

# Пример использования
import random

arr = [random.randint(1, 20) for _ in range(10)]
print("Исходный массив:", arr)

# Выполняем разделение
pivot_index = MyPartitionLomuto(arr)
print("Разделённый массив:", arr)
print("Индекс опорного элемента:", pivot_index)

"""
Исходный массив: [12, 20, 1, 18, 19, 15, 8, 5, 3, 13]
Разделённый массив: [12, 1, 8, 5, 3, 13, 20, 18, 19, 15]
Индекс опорного элемента: 5
"""